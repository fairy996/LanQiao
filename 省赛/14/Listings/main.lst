C51 COMPILER V9.60.7.0   MAIN                                                              03/24/2024 23:28:59 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Program Files\ARM\Core\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\HardWare) DEBUG 
                    -OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "sys.h"
   2          
   3          //************************å‚æ•°å®šä¹‰*******************************
   4          uchar NiXie[8] = {19,19,19,19,19,19,19,19};
   5          uchar pos[8] = {0,0,0,0,0,0,0,0};
   6          uchar led[8] = {0,0,0,0,0,0,0,0};
   7          
   8          uchar state1 = 0,state1_old = 0; //é»˜è®¤ä¸ºæ—¶é—´ç•Œé¢ 0 æ—¶é—´ç•Œé¢ 1å›æ˜¾ç•Œé¢ 2å‚æ•°ç•Œé¢ 3æ¸©æ¹
             -¿åº¦ç•Œé¢
   9          uchar state2 = 0; //é»˜è®¤ä¸ºæ¸©åº¦å›æ˜¾ç•Œé¢ 0 æ¸©åº¦å›æ˜¾ 1æ¹¿åº¦å›æ˜¾ 2 æ—¶é—´å›æ˜¾
  10          uchar trigger_count = 0;//æ¸©åº¦é‡‡é›†æ¬¡æ•°
  11          uchar temp_para = 30; //æ¸©åº¦å‚æ•°
  12          uchar rt_w[3] = {23,59,50};
  13          uchar re_r[3];
  14          uint temp_max = 0;//æœ€é«˜æ¸©åº¦
  15          uint temp_ave = 0;//å¹³å‡æ¸©åº¦
  16          uint temp = 0,temp_last = 0;//è·å–æ¸©åº¦å€¼
  17          uchar hum_max = 0,hum_ave = 0,hum = 0,hum_last = 0;//æœ€é«˜æ¹¿åº¦ å¹³å‡æ¹¿åº¦ æœ€ä½æ¹¿åº¦
  18          uchar access_h = 0;access_m = 0;//æœ€è¿‘ä¸€æ¬¡é‡‡é›†æ¸©åº¦å’Œæ¹¿åº¦çš„æ—¶é—´
  19          uchar Rd = 0,Rd_last = 0;//æœ¬æ¬¡è·å–å…‰æ•ç”µå‹å’Œä¸Šæ¬¡è·å–å…‰æ•ç”µå‹
  20          uchar trigger_flag = 0;//é‡‡é›†è§¦å‘æ ‡å¿— 0 æœªè§¦å‘ 1 è§¦å‘
  21          uint time_3s,time_1s;//å®šæ—¶å™¨3sç›¸å…³å‚æ•°
  22          uint freq;
  23          uchar data_flag = 0;//æ•°æ®æ˜¯å¦æœ‰æ•ˆ
  24          uchar Waring_flag = 0;//æ˜¯å¦æŠ¥è­¦
  25          uchar data_up = 0;//æ˜¯å¦æ¸©æ¹¿åº¦éƒ½å¢åŠ 
  26          //************************é©±åŠ¨ä»£ç *******************************
  27          void key_pro()
  28          {
  29   1          uchar key = key_scan();
  30   1          switch(key)
  31   1          {
  32   2              case 9://S5
  33   2                  if(state1 == 1)
  34   2                  {
  35   3                      if(state2 == 0)
  36   3                      {
  37   4                          state2 = 1; 
  38   4                      }
  39   3                      else if(state2 == 1)
  40   3                      {
  41   4                          state2 = 2;
  42   4                      }
  43   3                      else if(state2 == 2)
  44   3                      {
  45   4                          state2 = 0;
  46   4                      }
  47   3                  }
  48   2                  break;
  49   2              case 10://S9
  50   2      
  51   2                  break;
  52   2              case 13://S4
  53   2                  if(state1 == 0)
C51 COMPILER V9.60.7.0   MAIN                                                              03/24/2024 23:28:59 PAGE 2   

  54   2                  {
  55   3                      state2 = 0;
  56   3                      state1 = 1;
  57   3                  }
  58   2                  else if(state1 == 1)
  59   2                  {
  60   3                      state1 = 2;
  61   3                  }
  62   2                  else if(state1 == 2)
  63   2                  {
  64   3                      state1 = 0;
  65   3                  }
  66   2                  break;
  67   2              case 14://S8
  68   2      
  69   2                  break;
  70   2              case 15:
  71   2                  temp_ave = Access_Temp(1);
  72   2                  break;
  73   2          }
  74   1      }
  75          void nixie_pro()
  76          {
  77   1          if(state1 == 0)
  78   1          {
  79   2              DS1302_Time_Read(re_r);
  80   2              NiXie[2] = NiXie[5] = 18;
  81   2              NiXie[0] = re_r[0] / 10;
  82   2              NiXie[1] = re_r[0] % 10;
  83   2              NiXie[3] = re_r[1] / 10;
  84   2              NiXie[4] = re_r[1] % 10;
  85   2              NiXie[6] = re_r[2] / 10;
  86   2              NiXie[7] = re_r[2] % 10;
  87   2              pos[6] = 0;
  88   2          }
  89   1          else if(state1 == 1)
  90   1          {
  91   2              if(state2 == 0)
  92   2              {
  93   3                  pos[6] = 1;
  94   3                  NiXie[0] = 12;
  95   3                  NiXie[1] = 19;
  96   3                  NiXie[2] = temp_max / 100;
  97   3                  NiXie[3] = (temp_max % 100) / 10;
  98   3                  NiXie[4] = 18;
  99   3                  NiXie[5] = temp_ave / 100;
 100   3                  NiXie[6] = (temp_ave % 100) / 10;
 101   3                  NiXie[7] = temp_ave % 10;
 102   3              }
 103   2              else if(state2 == 1)
 104   2              {
 105   3                  pos[6] = 1;
 106   3                  NiXie[0] = 16;
 107   3                  NiXie[1] = 19;
 108   3                  NiXie[2] = hum_max / 100;
 109   3                  NiXie[3] = (hum_max % 100) / 10;
 110   3                  NiXie[4] = 18;
 111   3                  NiXie[5] = hum_ave / 100;
 112   3                  NiXie[6] = (hum_ave % 100) / 10;
 113   3                  NiXie[7] = hum_ave % 10;
 114   3              }
 115   2              else if(state2 == 2)
C51 COMPILER V9.60.7.0   MAIN                                                              03/24/2024 23:28:59 PAGE 3   

 116   2              {
 117   3                  NiXie[0] = 15;
 118   3                  NiXie[1] = trigger_count/10;
 119   3                  NiXie[2] = trigger_count%10;
 120   3                  NiXie[3] = access_h / 10;
 121   3                  NiXie[4] = access_h % 10;
 122   3                  NiXie[5] = 18;
 123   3                  NiXie[6] = access_m / 10;
 124   3                  NiXie[7] = access_m % 10;
 125   3                  pos[6] = 0;
 126   3              }
 127   2          }
 128   1          else if(state1 == 2)
 129   1          {
 130   2              NiXie[0] = 17;
 131   2              NiXie[6] = temp_para / 10;
 132   2              NiXie[7] = temp_para % 10;
 133   2              NiXie[1] = NiXie[2] = NiXie[3] = NiXie[4] = NiXie[5] = 19;
 134   2              pos[6] = 0;
 135   2          }
 136   1          else if(state1 == 3)
 137   1          {
 138   2              NiXie[0] = 14;
 139   2              NiXie[5] = 18;
 140   2              NiXie[1] = NiXie[2] = 19;
 141   2              NiXie[3] = temp / 100;
 142   2              NiXie[4] = (temp % 100) / 10;
 143   2              if(data_flag == 0)
 144   2              {
 145   3                  NiXie[6] = 10;
 146   3                  NiXie[7] = 10;
 147   3              }
 148   2              else
 149   2              {
 150   3                  NiXie[6] = hum / 10;
 151   3                  NiXie[7] = hum % 10;
 152   3              }
 153   2              pos[6] = 0;
 154   2          }
 155   1          NiXie_Show(NiXie,pos);
 156   1      }
 157          void led_pro()
 158          {
 159   1          switch(state1)
 160   1          {
 161   2              case 0:led[0] = 1;led[1] = 0;led[2] = 0;break;
 162   2              case 1:led[0] = 0;led[1] = 1;led[2] = 0;break;
 163   2              case 3:led[0] = 0;led[1] = 0;led[2] = 1;break;
 164   2          }
 165   1          if(Waring_flag == 1)
 166   1          {
 167   2              led[3] = 0;
 168   2              Delayms(100);
 169   2              led[3] = 1;
 170   2              Delayms(100);
 171   2          }
 172   1          else
 173   1              led[3] = 1;
 174   1          if(data_flag == 0)
 175   1              led[4] = 0;
 176   1          else
 177   1              led[4] = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              03/24/2024 23:28:59 PAGE 4   

 178   1          if(data_up == 1)
 179   1              led[5] = 0;
 180   1          else
 181   1              led[5] = 0;
 182   1          led_control(led);
 183   1      }
 184          unsigned int Access_Hum()
 185          {
 186   1          uint temp;
 187   1          freq *= 100;
 188   1          if (freq < 200 || freq > 2000)
 189   1              return 0;
 190   1          else
 191   1              temp = ((freq - 200) * 2 / 45 + 10) * 10;
 192   1              return temp;
 193   1      }
 194          void Access_Temp_Hum()
 195          {
 196   1          Rd_last = Rd;
 197   1          Rd = adc_read(0xa1);
 198   1          if(Rd < 80 && Rd_last > 80 && trigger_flag == 0)
 199   1          {
 200   2              trigger_flag = 1;
 201   2              if(++trigger_count == 100)
 202   2              {
 203   3                  trigger_count = 99;
 204   3              }
 205   2          }
 206   1          //è¢«è§¦å‘ä¸”è§¦å‘æ—¶é•¿è¾¾åˆ°3s
 207   1          else if(time_3s >= 3000 && trigger_flag == 1)
 208   1          {
 209   2              state1 = state1_old;
 210   2              trigger_flag = 0;
 211   2          }
 212   1          if(trigger_flag == 1)
 213   1          {
 214   2              state1_old = state1;
 215   2              state1 = 3;
 216   2              temp = Access_Temp(1);
 217   2              hum = Access_Hum();
 218   2              if(hum == 0)
 219   2              {
 220   3                  trigger_flag--;
 221   3                  data_flag = 0;
 222   3              }
 223   2              else
 224   2              {
 225   3                  data_flag = 1; //æ•°æ®æœ‰æ•ˆ
 226   3                  Waring_flag = (temp > temp_para);//æ˜¯å¦è¿›è¡Œæ¸©åº¦è¶Šç•ŒæŠ¥è­¦
 227   3                  data_up = (trigger_count >= 2)&&(temp > temp_last) && (hum > hum_last);
 228   3                  temp_max = (temp_max > temp) ? temp_max : temp;
 229   3                  hum_max = (hum_max > hum) ? hum_max : hum;
 230   3                  temp_ave = (temp_ave * (trigger_count - 1) + temp) / trigger_count;
 231   3                  hum_ave = (hum_ave * (trigger_count - 1) + hum) / trigger_count;
 232   3              }
 233   2          }
 234   1      }
 235          void Init_Timer0()
 236          {
 237   1          AUXR &= 0x7F; // å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 238   1          TMOD &= 0xF0; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼,ä¸å½±å“å®šæ—¶å™¨1çš„ä½¿ç”¨
 239   1          TMOD |= 0x05; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
C51 COMPILER V9.60.7.0   MAIN                                                              03/24/2024 23:28:59 PAGE 5   

 240   1          TL0 = 0;      // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 241   1          TH0 = 0;      // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 242   1          TF0 = 0;      // æ¸…é™¤TF0æ ‡å¿—
 243   1          TR0 = 1;      // å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 244   1      }
 245          void Timer1_Init(void) // 1ï¿½ï¿½ï¿½ï¿½@12.000MHz
 246          {
 247   1          AUXR &= 0xBF; 
 248   1          TMOD &= 0x0F; 
 249   1          TL1 = 0x18;  
 250   1          TH1 = 0xFC;  
 251   1          TF1 = 0;     
 252   1          TR1 = 1;      
 253   1          ET1 = 1;      
 254   1          EA = 1;      
 255   1      }
 256          void Service_Timer1() interrupt 3
 257          {
 258   1         
 259   1          if(++time_1s == 10)
 260   1          {
 261   2              time_1s = 0;
 262   2              freq = (TH0 << 8) | TL0;
 263   2              TH0 = 0;
 264   2              TL0 = 0;
 265   2          }
 266   1          if(trigger_flag == 1)
 267   1          {
 268   2              if(++time_3s >= 3000)
 269   2              {
 270   3                  
 271   3                  time_3s = 3001;
 272   3              }
 273   2          }
 274   1          else
 275   1              time_3s = 0;
 276   1      }
 277          //************************ä¸»å¾ªç¯*********************************
 278          void main(void)
 279          {
 280   1          Init_Sys();
 281   1          Timer1_Init();
 282   1          Init_Timer0();
 283   1          DS1302_Time_Write(rt_w);
 284   1          temp = Access_Temp(1);
 285   1          adc_read(0xa1);
 286   1          while(1)
 287   1          {
 288   2              Access_Temp_Hum();
 289   2              key_pro();
 290   2              nixie_pro();
 291   2              led_pro();
 292   2          }
 293   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1189    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     62    ----
C51 COMPILER V9.60.7.0   MAIN                                                              03/24/2024 23:28:59 PAGE 6   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
